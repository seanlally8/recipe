# This module is devoted to database queries (insertions, selections, etc.).
# TODO rewrite all sql code using ORM to reduce the clutter of MetaData

from sqlalchemy import (Column, ForeignKey, Integer, MetaData, String, Table,
                        and_, create_engine, insert, select)
from flask import session
from itertools import zip_longest

# Initiate metadata object so we can create Table objects to manipulate our data
metadata = MetaData()

# Create the table objects (corresponding to recipe.db)
ingredients = Table("ingredients", metadata,
                    Column("title_id", Integer(), ForeignKey("titles.id")),
                    Column("ingredient", String(), nullable=False)
                    )

instructions = Table("instructions", metadata,
                     Column("title_id", Integer(), ForeignKey("titles.id")),
                     #Column("instruction_title", String()),
                     Column("instruction", String(), nullable=False)
                     )

recipe_books = Table("recipe_books", metadata,
                     Column("title_id", Integer(), ForeignKey("titles.id")),
                     Column("user_id", Integer(), ForeignKey("users.id"))
                     )

titles = Table("titles", metadata,
               Column("id", Integer(), primary_key=True),
               Column("title", String(), nullable=False),
               Column("url", String())
               )

users = Table("users", metadata,
              Column("id", Integer(), primary_key=True),
              Column("username", String(), nullable=False, unique=True),
              Column("passhash", String(), nullable=False),
              )

# Initiate SQLAlchemy Engine
engine = create_engine("sqlite:///recipe.db?check_same_thread=False", echo=True, future=True)

# Create a connection object so we can execute commands/queries on the database.
connection = engine.connect()

# Create tables (if not created)
metadata.create_all(engine)

def update_tables(title, instructions_body, ingredients_list, url):
    """
    This function takes all the information scraped from the url -- or the
    OCRed image file -- and enters it into the database.
    """

    # Insert recipe title into titles table (title_id is autogenerated) 
    stmt = insert(titles).values(title=title, url=url)
    connection.execute(stmt)
    connection.commit()

    # Grab the title_id from the titles table so we can plug it in as a Foreign Key in other tables
    title_id = grab_title_id(title)

    # Insert ingredients into ingredients table.
    for ingredient in ingredients_list:
        print(ingredient)

        # Stop at extraneous instruction
        if ingredient.lower().startswith("for full"):
            break
        stmt = insert(ingredients).values(ingredient=ingredient, title_id=title_id)
        connection.execute(stmt)
    connection.commit()

    # Insert instructions into instructions table
    for entry in instructions_body:
        print(entry)
        print()

        # If the instruction is short, then skip it
        if len(entry) < 15:
            continue

        # Otherwise contine entering the entries (with title_ids) into the database 
        stmt = insert(instructions).values(instruction=entry,
                                            title_id=title_id)
        connection.execute(stmt)
    connection.commit()

    # This function is only called if the recipe doesn't exist in the db. 
    # So we know it isn't in the user's library.

    # Thus, we add it.
    insert_title(title_id)

    return True


def grab_title_id(title):
    """
    This function returns the title id for a given recipe
    """

    stmt = select(titles.c.id).where(titles.c.title == title)
    title_id = connection.execute(stmt).fetchall()
    title_id = title_id[0].id 

    return title_id


def insert_title(title_id):
    """
    This function inserts a title into the user's 'library', i.e., a place
    in the database where the title is associated with the user
    """

    stmt = insert(recipe_books).values(user_id=session["user_id"], title_id=title_id)
    connection.execute(stmt)
    connection.commit()

    return True